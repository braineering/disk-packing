#===============================================================================
# DISK PACKING (Script)
#===============================================================================
reset;
reset options;

#===============================================================================
# PROBLEM DECLARATION
#===============================================================================
model disk-packing.mod;
data disk-packing.dat;

#===============================================================================
# AMPL OPTIONS
#===============================================================================
option prompt1 "[AMPL]> ";
option display_width 80;
option display_1col 0;
option relax_integrality 1;

#===============================================================================
# OUTPUT PARAMETERS
#===============================================================================
param fileResults symbolic; # output file for results
let fileResults := ("out-"&N&".txt");

#===============================================================================
# SOLVER OPTIONS
#===============================================================================
option snopt_options "outlev=1";
#option snopt_options "relax=1";
#option snopt_options 'Feasibility_tolerance=1.0e-12';
#option snopt_options 'iterations=1000000';
option solver snopt;

#===============================================================================
# HEADER
#===============================================================================
print
"============================================================================= \
DISK PACKING PROBLEM \
Model : disk-packing.mod \
Data  : disk-packing.dat \
Solver: SNOPT \
Author: Giacomo Marciani <gmarciani@acm.org> \
        Michele Porretta <mporretta@acm.org> \
=============================================================================="
> (fileResults);

#===============================================================================
# PROBLEM PARAMETERS
#===============================================================================
param Xlb := 0.0; # lower bound for disks center (X coordinate)
param Xub := 1.0; # upper bound for disks center (X coordinate)
param Ylb := 0.0; # lower bound for disks center (Y coordinate)
param Yub := 1.0; # upper bound for disks center (Y coordinate)

#===============================================================================
# ALGORITHM PARAMETERS
#===============================================================================
param Xstart{1..N}; # initial    disks center (X coordinate)
param Ystart{1..N}; # initial    disks center (Y coordinate)
param Xlocal{1..N}; # local      disks center (X coordinate)
param Ylocal{1..N}; # local      disks center (Y coordinate)
param Xbest {1..N}; # local best disks center (X coordinate)
param Ybest {1..N}; # local best disks center (Y coordinate)
param Xmax{1..N};   # best       disks center (X coordinate)
param Ymax{1..N};   # best       disks center (Y coordinate)
param Xtilde{1..N}; # perturb    disks center (X coordinate)
param Ytilde{1..N}; # perturb    disks center (Y coordinate)

param maxSearch;    # maximum number of outer loop iterations
param maxNoImprove; # maximum number of optimisation steps with no improvement
param noImprove;    # number of local steps with no improvement
param nLocalOpt;    # number of local optimisation steps

param fBest;        # best objective function
param fMax;         # current max objective function
param fStar;        # global optimum for objective function
param epsilon;      # epsilon
param Xpert{1..N};  # perturbation for disks center (X coordinate)
param Ypert{1..N};  # perturbation for disks center (Y coordinate)

let maxSearch := 1000;
let maxNoImprove := 50;
let noImprove := 0;
let nLocalOpt := 0;

let fBest := 0.0
let fMax  := 0.0;
let fStar := 0.0;

for {k in 1..maxSearch}{ # for k in maxSearch
  #=============================================================================
  # START
  #=============================================================================
  let {i in 1..N} Xstart[i] := Uniform(Xlb,Xub); # random initial disks center (X coordinate)
  let {i in 1..N} Ystart[i] := Uniform(Ylb,Yub); # random initial disks center (Y coordinate)
  let {i in 1..N} X[i] := Xstart[i] # set decision variables to random initial disks center (X coordinate)
  let {i in 1..N} Y[i] := Ystart[i] # set decision variables random initial disks center (X coordinate)

  #=============================================================================
  # LOCAL OPTIMISATION
  #=============================================================================
  solve; # local optimisation step
  let nLocalOpt := nLocalOpt+1; # increment number of local optimisation steps

  #=============================================================================
  # UPDATE
  #=============================================================================
  if (solve_result_num == 0) then { # if solve_result_num == 0
    let {i in 1..N} Xlocal := X[i]; # local update for disks center (X coordinate)
    let {i in 1..N} Ylocal := Y[i]; # local update for disks center (Y coordinate)
    let fBest := f;                 # local update for objective function
    let {i in 1..N} Xbest[i] := Xlocal[i] # local best update for disks center (X coordinate)
    let {i in 1..N} Ybest[i] := Ylocal[i] # local best update for disks center (Y coordinate)
    printf "Found stationary point with objective function value f = %12.6f\n", f >> (fileResults);

    if (fBest > fMax) then { # if fBest > fMax
      let fMax := fBest; # update maximum of objective function with local best
      let {i in 1..N} Xmax[i] := Xlocal[i] # update disks center (X coordinate)
      let {i in 1..N} Ymax[i] := Ylocal[i] # update disks center (Y coordinate)
      if (abs(fStar-fMax) < epsilon) then { # if abs(fStar-fMax) < epsilon
        printf "Found global optimum\n" >> (fileResults);
        break;
      } # abs(fStar-fMax) < epsilon
    } # if fBest > fMax
  } else { # if solve_result_num != 0
    repeat { # repeat until solve_result_num == 0
      #=========================================================================
      # IMPROVE: START
      #=========================================================================
      let {i in 1..N} Xstart[i] := Uniform(Xlb,Xub); # random initial disks center (X coordinate)
      let {i in 1..N} Ystart[i] := Uniform(Ylb,Yub); # random initial disks center (Y coordinate)
      let {i in 1..N} X[i] := Xstart[i] # set decision variables to random initial disks center (X coordinate)
      let {i in 1..N} Y[i] := Ystart[i] # set decision variables random initial disks center (X coordinate)

      #=========================================================================
      # IMPROVE: LOCAL OPTIMISATION
      #=========================================================================
      solve; # local optimisation step
      let nLocalOpt := nLocalOpt+1; # increment number of local optimisation steps
    } until (solve_result_num == 0); # end repeat until solve_result_num == 0

    #===========================================================================
    # IMPROVE: UPDATE
    #===========================================================================
    let {i in 1..N} Xlocal := X[i]; # local update for disks center (X coordinate)
    let {i in 1..N} Ylocal := Y[i]; # local update for disks center (Y coordinate)
    let fBest := f;                 # local update for objective function
    let {i in 1..N} Xbest[i] := Xlocal[i] # local best update for disks center (X coordinate)
    let {i in 1..N} Ybest[i] := Ylocal[i] # local best update for disks center (Y coordinate)
    printf "Found stationary point with objective function value f = %12.6f\n", f >> (fileResults);

    if (fBest > fMax) then { # if fBest > fMax
      let fMax := fBest; # update maximum of objective function with local best
      let {i in 1..N} Xmax[i] := Xlocal[i] # update disks center (X coordinate)
      let {i in 1..N} Ymax[i] := Ylocal[i] # update disks center (Y coordinate)
      if (abs(fStar-fMax) < epsilon) then { # if abs(fStar-fMax) < epsilon
        printf "Found global optimum\n" >> (fileResults);
        break;
      } # abs(fStar-fMax) < epsilon
    } # if fBest > fMax
  } # if solve_result_num != 0

  if (abs(fStar-fMax) < epsilon) then { # if abs(fStar-fMax) < epsilon
    printf "Found global optimum\n" >> (fileResults);
    break;
  } # abs(fStar-fMax) < epsilon

  #=============================================================================
  # LOOP
  #=============================================================================
  repeat while (noImprove <= maxNoImprove) { # repeat while (noImprove <= maxNoImprove)
    #===========================================================================
    # PERTURBATION
    #===========================================================================
    let {i in 1..N} Xpert[i] := Uniform(-0.5,0.5);   # random perturbation for disks center (X coordinate)
    let {i in 1..N} Ypert[i] := Uniform(-0.5,0.5);   # random perturbation for disks center (Y coordinate)
    let {i in 1..N} Xtilde[i] := Xlocal[i]+Xpert[i]; # set random perturbation for disks center (X coordinate)
    let {i in 1..N} Ytilde[i] := Ylocal[i]+Ypert[i]; # set random perturbation for disks center (Y coordinate)
    let {i in 1..N} X[i] := Xtilde[i];               # set decision variables to random perturbation for disks center (X coordinate)
    let {i in 1..N} Y[i] := Ytilde[i];               # set decision variables to random perturbation for disks center (Y coordinate)
    printf "Perturbated starting point with objective function value f = %12.6f\n", f >> (fileResults);

    #===========================================================================
    # PERTURBATION: LOCAL OPTIMISATION
    #===========================================================================
    solve; # local optimisation step
    let nLocalOpt := nLocalOpt+1; # increment number of local optimisation steps
    printf "Perturbated starting point with objective function value f = %12.6f\n", f >> (fileResults);

    if (f > fBest) && (solve_result_num == 0) then { # if (f > fBest) && (solve_result_num == 0)
      #===========================================================================
      # IMPROVE: UPDATE
      #===========================================================================
      let {i in 1..N} Xlocal := X[i]; # local update for disks center (X coordinate)
      let {i in 1..N} Ylocal := Y[i]; # local update for disks center (Y coordinate)
      let fBest := f;                 # local update for objective function
      let {i in 1..N} Xbest[i] := Xlocal[i] # local best update for disks center (X coordinate)
      let {i in 1..N} Ybest[i] := Ylocal[i] # local best update for disks center (Y coordinate)
      let noImprove := 0; # reset number of optimisation step with no improvement
      printf "Found better stationary point with objective function value f = %12.6f\n", f >> (fileResults);

      if (fBest > fMax) then { # if fBest > fMax
        let fMax := fBest; # update maximum of objective function with local best
        let {i in 1..N} Xmax[i] := Xlocal[i] # update disks center (X coordinate)
        let {i in 1..N} Ymax[i] := Ylocal[i] # update disks center (Y coordinate)
        if (abs(fStar-fMax) < epsilon) then { # if abs(fStar-fMax) < epsilon
          printf "Found global optimum\n" >> (fileResults);
          break;
        } # abs(fStar-fMax) < epsilon
      } # if fBest > fMax
    } # if (f > fBest) && (solve_result_num == 0)
    else { # if (f <= fBest) || (solve_result_num != 0)
      let noImprove := noImprove+1; # increment number of steps with no improvement
      printf "No improvement for perturbated point\n" >> (fileResults);
    } # if (f <= fBest) || (solve_result_num != 0)
  } # repeat while (noImprove <= maxNoImprove)

  if (abs(fStar-fMax) < epsilon) then { # if abs(fStar-fMax) < epsilon
    printf "Found global optimum\n" >> (fileResults);
    break;
  } # abs(fStar-fMax) < epsilon

} # for k in maxSearch

#===============================================================================
# SHOW RESULTS
#===============================================================================
printf "Best value: %12.6f\n", fMax >> (fileResults);
for {i in 1..N} { # for k in 1..N
  printf "[%d] Center (%1.12f,%1.12f)\n", k, Xmax[i], Ymax[i] >> (fileResults);
} # for k in 1..N
printf "Number of local optimisation steps: %d\n", nLocalOpt >> (fileResults);
